// /*
// 너비가 같은 N개의 나무 판자를 붙여 세운 울타리가 있습니다.
// 판자의 높이가 다 달라져 교체하기로 하였는데 이때 버리는 울타리의 일부를 직사각형으로 잘라내 재활용 하려합니다.
// 각 판자의 높이가 주어질 때 잘라낼 수 있는 직사각형의 최대 크기를 계산하는 프로그램을 구현하시오.

// 시간 & 메모리 제한
// 프로그램은 1초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 합니다.

// 입력
// 첫 줄에 테스트 케이스 C의 수가 주어집니다. (C <= 50)
// 각 테스트 케이스의 첫 줄에는 판자의 수 N이 주어집니다. (1 <= N <= 20000)
// 각 판자의 높이가 주어집니다. 높이는 10000이하의 자연수입니다.
// 판자의 너비는 모두 1입니다.

// 출력
// 각 테스트 케이스당 정수 하나를 한 줄에 출력합니다. 이 정수는 주어진 울타리에서 잘라낼 수 있는 최대 직사각형의 크기를 나타내야 합니다.

// 입력
// 3
// 7
// 7 1 5 9 6 7 3
// 7
// 1 4 4 4 4 1 1
// 4
// 1 8 2 2

// 출력
// 20
// 16
// 8
// */

// /*
// 넓이가 가장 넓은 면적으로 잘라내야한다.
// 1칸씩 옮겨가면서 높거나 같으면 더 넓은 것(2*4 < 3*5)
// 1칸 더 낮더라고 넓을 수 있음 (2*4 < 3*3)

// 가장 높은곳 혹은 중간에서 시작해서 양 옆의 낮은 곳으로 옮겨가면서 연산? [(1*5 < 2*4), (2*4 < 3*3). (3*3 > 4*2)...]
// 항상 더 낮은 것이 넓지 않음! 
// 그냥 기준 판자를 하나 잡고 왼쪽과 오른쪽중 더 높은쪽으로 확장하며 각 넓이를 저장하고 비교하자
// */

// #include <iostream>
// #include <vector>
// #include <algorithm> 

// using namespace std;

// vector<int> h;

// // left, right 범위 안에서 최대 직사각형 넓이 계산
// int AreaCalc(int left, int right) {
//     // 1. 기저 사례: 판자가 1개일 때
//     if (left == right) return h[left];

//     // 2. 분할: 중간 지점 설정
//     int mid = (left + right) / 2;

//     // 3. 정복: 왼쪽 부분과 오른쪽 부분에서 각각 최대 넓이를 구함
//     int ret = max(AreaCalc(left, mid), AreaCalc(mid + 1, right));

//     // 4. 결합: 중간 지점을 걸치는 직사각형의 최대 넓이를 구함
//     int lo = mid;
//     int hi = mid + 1;
//     int height = min(h[lo], h[hi]); // 중간 두 판자 중 낮은 높이로 시작

//     // 중간 2개 칸의 넓이로 초기값 갱신
//     ret = max(ret, height * 2);

//     // 전체 범위(left~right) 안에서 양쪽으로 확장
//     while (left < lo || hi < right) {
//         // 오른쪽으로 확장할 수 있고, (왼쪽으로 갈 수 없거나, 오른쪽 판자가 더 높다면)
//         // -> 높이가 높은 쪽으로 확장해야 유리함
//         if (hi < right && (lo == left || h[lo - 1] < h[hi + 1])) {
//             hi++;
//             height = min(height, h[hi]); // 확장은 하되 높이는 가장 낮은 판자에 맞춰짐
//         }
//         else {
//             lo--;
//             height = min(height, h[lo]);
//         }
//         // 확장 후 넓이 갱신 (가로: hi - lo + 1)
//         ret = max(ret, height * (hi - lo + 1));
//     }

//     return ret;
// }

// int main() {

//     int C;
//     cin >> C;

//     while (C--) {
//         int N;
//         cin >> N;

//         h.clear(); // 데이터 초기화
//         h.resize(N); // 벡터 크기 미리 할당

//         for (int i = 0; i < N; i++) {
//             cin >> h[i];
//         }

//         // 0번 인덱스부터 N-1번 인덱스까지
//         cout << AreaCalc(0, N - 1) << "\n";
//     }

//     return 0;
// }